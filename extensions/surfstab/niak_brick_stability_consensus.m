function [files_in,files_out,opt] = niak_brick_stability_consensus(files_in,files_out,opt)
% Generate consensus clusters based on estimated stability matrices
%
% SYNTAX:
% [FILES_IN,FILES_OUT,OPT] = NIAK_BRICK_STABILITY_CONSENSUS(FILES_IN,FILES_OUT,OPT)
%
% _________________________________________________________________________
% INPUTS:
% FILES_IN
%   STAB
%       (string or cell of strings) path or paths to the stability matrices
%       generated by the batches.
%
%   ROI
%       (string) path to the file containing the region growing results
%
% FILES_OUT
%   (string, optional) the path to the output .mat file
%
% OPT
%   (structure) with the following fields:
%
%   SCALE_GRID
%       (vector of K integers) the scales used to generate the stability
%       maps in FILES_IN.STAB. This has to be specified.
%
%   SCALE_TAR
%       (vector, optional) when this is not empty, the target scales
%       requested here will be selected and the optimal replication scales
%       will be chosen such that the silhouette criterion is maximized.
%       Note that SCALE_TAR must be a subset of SCALE_GRID.
%
%   CLUSTERING
%      (structure, optional) with the following fields :
%
%      TYPE
%         (string, default 'hierarchical') the clustering algorithm
%         Available options :
%            'hierarchical': a HAC based on correlation.
%
%      OPT
%         (structure, optional) options that will be  sent to the
%         clustering command. The exact list of options depends on
%         CLUSTERING.TYPE:
%         'hierarchical' : see OPT in NIAK_HIERARCHICAL_CLUSTERING
%
%   NAME_STAB
%      (string, default 'stab') the name of the variable that contains
%      the stability matrix.
%
%   NAME_ROI
%       (string, default 'roi') the name of the variable in FILES_IN.ROI
%       that contains the partition into atoms
%
%   RAND_SEED
%      (scalar, default []) The specified value is used to seed the random
%      number generator with PSOM_SET_RAND_SEED. If left empty, no action
%      is taken.
%
%   FLAG_VERBOSE
%      (boolean, default true) turn on/off the verbose.
%
%   FLAG_TEST
%      (boolean, default false) if the flag is true, the brick does not do anything
%      but updating the values of FILES_IN, FILES_OUT and OPT.
%
% _________________________________________________________________________
% OUTPUTS:
%
% The structures FILES_IN, FILES_OUT and OPT are updated with default
% valued. If OPT.FLAG_TEST == 0, the specified outputs are written.
%
% _________________________________________________________________________
% COMMENTS:
%
% Copyright (c) Pierre Bellec, Sebastian Urchs
%   Centre de recherche de l'institut de Gériatrie de Montréal
%   Département d'informatique et de recherche opérationnelle
%   Université de Montréal, 2010-2014
%   Montreal Neurological Institute, 2014
% Maintainer : pierre.bellec@criugm.qc.ca
% See licensing information in the code.
% Keywords : clustering, surface analysis, cortical thickness, stability
%            analysis, bootstrap, jacknife.

% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
% THE SOFTWARE.

%% TODO:

%% Initialization and syntax checks

% Syntax
if ~exist('files_in','var')||~exist('files_out','var')
    error('niak:brick','syntax: [FILES_IN,FILES_OUT,OPT] = NIAK_BRICK_STABILITY_CONSENSUS(FILES_IN,FILES_OUT,OPT).\n Type ''help niak_brick_stability_consensus'' for more info.')
end

% FILES_IN
list_fields   = { 'stab' , 'roi' };
list_defaults = { NaN    , NaN   };
files_in = psom_struct_defaults(files_in,list_fields,list_defaults);

% FILES_OUT
if ~ischar(files_out)
    error('FILES_OUT should be a string!');
end

% Options
if nargin < 3
    opt = struct;
end

opt_clustering.type   = 'hierarchical';
opt_clustering.opt    = struct();

list_fields   = { 'clustering'   , 'name_stab' , 'name_roi' , 'flag_verbose' , 'scale_grid' , 'scale_tar' , 'rand_seed' , 'flag_test' };
list_defaults = { opt_clustering , 'stab'      , 'roi'      , true           , NaN          , []          , []          , false       };
opt = psom_struct_defaults(opt,list_fields,list_defaults);

opt.clustering.opt.flag_verbose = opt.flag_verbose;
opt.clustering = psom_struct_defaults(opt.clustering,{'type','opt'},{'hierarchical',struct});

% If the test flag is true, stop here !
if opt.flag_test == 1
    return
end

%% Seed the random generator
if ~isempty(opt.rand_seed)
    psom_set_rand_seed(opt.rand_seed);
end

%% Read the data
roi = load(files_in.roi);
part_roi = roi.(opt.name_roi);
data = load(files_in.stab);

%% Sanity Checks
% If target scale is set, check if there are even enough ROIs for the scale
% we are looking for
if ~isempty(opt.scale_tar)
    num_roi = max(part_roi);
    if num_roi < max(opt.scale_tar)
        error(['You want more scales (%d) from the consensus ',...
                'step than we have ROIs (%d). ',...
                'This will not work!\n'], max(opt.scale_tar), num_roi);
    end
end

% See if the requested stability variable exists in FILES_IN.STAB
if ~isfield(data,opt.name_stab)
    error('I could not find the variable called %s in the file %s',...
          opt.name_stab, files_in.stab)
else
    stab = data.(opt.name_stab);
end

% See if a grid scale was supplied
if isempty(opt.scale_grid)
    error(['Please specify the scale of the stability matrix in '...
           'OPT.SCALE_GRID. Current scale is empty.\n']);
end

% Check if the scale in OPT.SCALE_GRID has the same number of values as the
% stability map has entries
stab_num_sc = size(stab, 2);
opt_num_sc = length(opt.scale_grid);
if stab_num_sc ~= opt_num_sc
    % We don't have the correct number of grid scale values supplied
    error(['The number of scales in OPT.SCALE_GRID (%d) does not match '...
           'the number of stability maps (%d).'], opt_num_sc, stab_num_sc);
end
% If available, check if the grid scales in the stability file and in
% opt.grid_scale match
if isfield(data, 'scale_grid')
    if ~all(data.scale_grid == opt.scale_grid)
        warning(['The grid scale in FILES_IN.STAB does not match with the '...
                 'grid scale in OPT.SCALE_GRID. This could be a problem.']);
    end
end

%% Generate consensus clustering
% Perform the consensus clustering - here, every stability map will be
% clustered into the same number of targets that it was generated with
opt_c.clustering = opt.clustering;
opt_c.flag_verbose = opt.flag_verbose;
opt_c.nb_classes = opt.scale_grid;

[tmp_part, order, sil,...
 intra, inter, hier, scale_tar] = niak_consensus_clustering(stab,opt_c);

for sc_id = 1:length(opt.scale_grid);
    stab_mat = niak_vec2mat(stab(:,sc_id));
    [sil(:,sc_id),...
     intra(:,sc_id), inter(:,sc_id)] = niak_build_avg_silhouette(stab_mat,...
                                                                 hier{sc_id},...
                                                                 false);
end

% Bring the partition back into the original space
num_part = numel(opt.scale_grid);
V = length(part_roi);
part = zeros(V,num_part);
for part_index = 1:num_part
    part(:,part_index) = niak_part2vol(tmp_part(:, part_index),part_roi);
end

% Get the scale of the partiton - here still equivalent to opt.scale_grid
scale_tar = max(part);
scale_rep = opt.scale_grid;

if ~isempty(opt.scale_tar)
    % Find the replication clusters that would maximize silhouette for the
    % target clusters we just generated
    % Set the fixed neighbourhood
    neigh = [0.7,1.3];

    [sil_max, scales_max] = niak_build_max_sil(sil, opt.scale_grid(:), neigh, 1);

    % Find the optimal stochastic scales for the target scales
    scale_rep = scales_max(opt.scale_tar)';
    % Find the indices of the optimal stochastic scales in opt.scale_grid
    k_ind = arrayfun(@(x) find(opt.scale_grid == x,1,'first'), scale_rep);
    % Find the indices of the target scales in opt.scale
    p_ind = arrayfun(@(x) find(opt.scale_grid == x,1,'first'), opt.scale_tar);
    % Truncate the inputs to reflect the adapted stochastic scales
    sil = sil(:, k_ind);
    part = part(:, p_ind);
    % Get the scale of the partition
    scale_tar = max(part);
    % Get the grid scale for saving it
    scale_grid = opt.scale_grid(k_ind);
    stab = stab(:, k_ind);
    hier = hier(k_ind);
    save(files_out, 'part', 'scale_tar', 'scale_rep', 'scale_grid', 'order',...
         'sil', 'intra', 'inter', 'hier', 'stab');

else
    %% Save the results
    scale_grid = opt.scale_grid;
    save(files_out,'part', 'scale_tar', 'scale_rep', 'scale_grid', 'order',...
         'sil','intra','inter','hier','stab');
end
